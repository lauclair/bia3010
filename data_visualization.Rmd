---
title: "Visualisation des résultats : tableaux et graphiques"
author: "Laurie Auclair & Jocelyn Lauzon"
date: "10/09/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br>

# Importer les données
```{r}
library(datasets)
data(iris)
```

<br>

# Exploration de données

Avant de débuter des analyses, il est important de se familisariser avec son
jeu de données afin d'avoir une idée de sa structure. Cette étape permet
d'identifier des motifs, des tendances ou des relations préalablement aux tests 
statistiques, puis de vérifier la qualité des données. Elle permet aussi d'évaluer
si les données ont besoin d'être transformées avant de procéder aux analyses.

## Quelques fonctions de base

Pour vérifier le nombre de lignes et de colonnes de votre *dataset*:
```{r}
dim(iris)
```

Pour voir les 6 premières lignes du jeu de données:
```{r}
head(iris)
```

Pour connaître le nom des colonnes:
```{r}
names(iris)
```

Pour vérifier la classe de chaque variable dans le *dataset*:
```{r}
str(iris)
```

Pour obtenir certaines statistiques descriptives de base, telles que le minimum, 
le maximum puis la moyenne (variables continues), ainsi que le nombre 
d'observations (variables catégoriques):
```{r}
summary(iris)
```


Pour oconnaître les niveaux d'une variable catégorique:
```{r}
levels(iris$Species)
```

<br>

## Visualisation d'un jeu de données

La fonction `plot()` est une fonction versatile qui permet de créer une grande
variété de figures avec les données brutes. Dépendemment du type de donnée et des arguments fournis à la fonction, `plot()` peut générer plusieurs types de figures comme:

Une seule matrice de *scatterplots* figure peut être créée avec toutes les variables 
continues.
```{r}
plot(iris)
```

Pour créer un *scatterplot* de la relation entre une variable spécifique et une autre,
il suffit d'entrer celles-ci dans la fonction, séparées par le signe **~**. Par 
exemple, si on veut visualiser la relation entre la longueur des sépales et celle 
des pétales dans le jeu de données `iris`, on peut l'écrire ainsi:

```{r}
plot(iris$Sepal.Length~iris$Petal.Length)
```

À l'aide de la fonction `boxplot()`, on peut visualiser la dispersion d'une variable selon dles groupes d'une variable catégorique. Ce type de figure permet aussi d'identifier rapidement des valeurs aberrantes ou des anomalies. 

```{r}
boxplot(iris$Petal.Length~iris$Species)
```

La fonction `hist()` génère un histogramme de la variable qui y est précisée.

```{r}
hist(iris$Sepal.Width)
```

<br>

# Conseils pour des figures et tableaux réussis

Les figures sont des représentations visuelles des résultats. Elles rendent la lectures des résultats principaux plus facile et permettent de mettre en évidence des tendances ou motifs intéressants. On veut pouvoir la comprendre sans avoir à osciller entre la figure et le texte. Elles doivent contenir:

+ **Un titre descriptif**: les variables mesurées, les unités de mesure, le nom commun et en latin du taxon (si nécessaire). Le titre doit fournir assez d'information pour qu'on comprenne le contexte de la figure sans devoir se référer au texte.

+ **Titre des axes**: doivent comprendre la variable et son unité de mesure

+ **Barres d'erreurs**: les inclure pour indiquer l'écart-type autour de la moyenne

+ **Légende**: une petite légende peut être nécessaire pour distinguer les traitements (couleur, type de ligne, etc.)

+ **Indice de significativité**: la valeur p d'une relation, des astérisques au-dessus de graphes à barres pour indiquer si la relation est significative, etc.

Les tableaux sont un bon choix pour présenter de l'information numérique détaillée. Ils présentent habituellement des résultats plus complexes qui seraient trop encombrants à inclure dans une figure ou dans le texte. Généralement, si les données ne peuvent être présentées en une ou deux phrases, un tableau est nécessaire. Les lignes et les colonnes doivent contenir le nom de la variable ainsi que l'unité de mesure. Un tableau résumé des statistiques peut inclure, par exemple, la moyenne, l'écart-type, les intervalles de confiances, les degrés de liberté, la valeur p et autres statistiques (comme la *F value*).


## Légende d'une figure ou d'un tableau
Les légendes servent à compléter l'information qui est présentée dans le tableau ou la figure. On y retrouve entre autre les tailles d'échantillons (n), valeur p, des descriptions des abréviations, la méthode de collection, le nombre de réplicats, etc.

## Annexe ou pas?
Les données ou les figures qui ne contribuent pas directement à l'histoire principale de votre rapport peuvent être rassemblées en annexes. Dans cette section, on peut retrouver, par exemple, des cartes du site d'échantillonnage, du matériel utilisé pour récolter les données, des tableaux avec davantage d'informations sur les modèles (pas de capture d'écran du *summary*!), etc.


<br>

# Coder des graphiques avec ggplot (Sabrina)

## Observer la stucture des données univariées
```{r}
summary(iris)
```

# ANOVA (Sabrina)
La fonction de base plot() peut être utile pour visualiser rapidement un jeu de données, par exemple avec un histogramme. Par contre, vous verrez que son utilisation peut devenir  limitée lorsqu'il s'agit de réaliser des figures plus complexes ou simplement modifier certains paramètres graphiques. 

C'est pour cela que nous suggérons d'utiliser la fonction ggplot(), du package "ggplot2". Cette fonction permet de réaliser des graphiques de façon plus intuitive et permet de les mettre en page plus facilement qu'avec la fonction plot(). Elle est aussi mieux documentée, il est donc plus facile de comprendre et utiliser les différents aspects de la fonction. Google est d'ailleurs votre meilleur allié pour la réalisation de vos figures!

Contrairement à la fonction plot(), ggplot() fonctionne par couches. 
Une figure ggplot() commence avec la fonction ggplot(). Elle sert à "préparer" la figure: on spécifie le jeu de données à utiliser, puis on choisit les variables qui formeront nos axes. 

La fonction ggplot nécessite deux arguments: le dataset (jeu de données), puis l'argument "aes()". Ce dernier nous permet d'assigner des variables du dataset aux composantes du graphique (par exemple, les axes x et y). Voici un exemple, toujours avec le jeu de données Iris. Nous allons tester si la largeur des sépales diffère entre les espèces.

(Revoir l'atelier 3 pour l'explication de l'ANOVA, incluant les postulats et critères d'utilisation, que je passe ici)


# Régression linéaire (Sabrina)



# Autres modèles univariés... (Sabrina, à voir si c'est pertinent)



# Ordinations (Jocelyn)

## Importer les données multivariées
```{r}
library(vegan)
data(varespec) # matrice de communautés
data(varechem) # données environnementales
varechem <- scale(varechem) # centrer-réduire
```

## CA (Analyse de correspondance)

Faire l'ordination
```{r}
ca.varespec<-cca(varespec)
```
Tests statistiques avec la fonction **envfit**
```{r}
envfit.varechem<-envfit(ca.varespec, varechem)
```

### Fonction plot

```{r}
plot(ca.varespec)
```

On pourrait aussi choisir de ne visualiser que les sites ou que les espèces.
```{r}
par(mfrow = c(1, 2))
plot(ca.varespec, display = "sites")
plot(ca.varespec, display = "species")
```

```{r}
par(mfrow=c(1,2))
plot(ca.varespec, scaling=1, type="none", main='CA - biplot scaling 1', 
     xlab=c("CA1 (%)", round((ca.varespec$CA$eig[1]/sum(ca.varespec$CA$eig))*100,2)),
     ylab=c("CA2 (%)", round((ca.varespec$CA$eig[2]/sum(ca.varespec$CA$eig))*100,2)))
points(scores(ca.varespec, display="sites", choices=c(1,2), scaling=1), pch=21, col="black", bg="steelblue", cex=1.2)
text(scores(ca.varespec, display="species", choices=c(1), scaling=1),
     scores(ca.varespec, display="species", choices=c(2), scaling=1),
     labels=rownames(scores(ca.varespec, display="species", scaling=1)),col="red", cex=0.8)
```

Incorporer les vecteurs environnementaux à la figure d'ordination
```{r}
plot(ca.varespec, display = "sites")
plot(envfit.varechem)
plot(envfit.varechem, p.max = 0.05, col = "red")#Les correlations significatives apparaissent en rouge
```


### Fonction ordiplot
```{r}
ordiplot(ca.varespec)
```

```{r}
#pl <- ordiplot(ca.varespec, type = "none", 
               #xlab=c("CA1", round((ca.varespec$CA$eig[1]/sum(ca.varespec$CA$eig))*100, 2)), 
               #ylab = "PC2 (16,1%)")
#points(pl, "sites", pch=21, col="black", bg="forestgreen")
#text(pl, "species", col="black", cex=0.9)
#text(pl, "species", col="black", cex=0.9, 
#     select = c("a.PRPE","a.ACSP","a.COCO","A.BEAL","h.RUID","h.ABBA","h.COCO","h.COCA","h.VILA","a.ACSA","a.ABBA","a.ALRU","A.BEPA","A.ABBA","h.DRIN"))
#ordihull(pca_comm, env_scaled$milieu, label = T, draw ="polygon", col=c("darkgreen","grey"), alpha=0.4, lwd = 1, kind=sd)
```


### ggplot2 + ggord

```{r}
library(ggplot2)
#library(ggord)
```


```{r}
#ggord(ca.varespec, ca.varespec, grp_in = NULL, axes = c("1", "2"))
```


## PCA

### Fonction biplot

La fonction biplot ne peut être qu'utilisée avec ordination linéaire comme PCA.

--> afficher d'autres axes que 1 et 2....
--> envfit
